SERVER

>MAIN THREAD

while(){
    -attendi una connessione
    -accetta
    -analizza il messaggio inviato, e metti il client in
    --CODA SENDER: ordinata, con priorità basata sull'ordine
    --LISTA RECIEVER: semplice lista di contenimento degli id
    -Segnala il posizionamento in coda al client

    if(!robot_in_uso){
        -Imposta timeout per il primo sender(allo scadere, si caccia)

        Per il SENDER al primo posto, verifica se il reciever è presente:

        if(presente)
            robot_in_uso=true;
            -crea un thread che gestisca la connessione tra i due coinvolti
            -attendi la fine del lavoro
            robot_in_uso=false;
            -elimina i due dalle liste
    }
}

>ROBOT THREAD(input: i dati dei due client coinvolti)

- Invia al sender "Il robot sta arrivando"
- Invia al reciever "Il robot sta andando a raccogliere il pacco"

    <muovi il robot fino all' Aula1>

- Invia al sender "Hai y secondi per posizionare il pacco. Appena hai fatto, conferma"
- Invia al reciever "Il robot sta aspettando il pacco"
- Attendi il sender(se timeout, allora riporta robot a base, e invia "ERRORE: il sender non ha confermato")

- Invia al sender "Il robot sta per partire verso Aula2"
- Invia al reciever "Il robot sta arrivando da te. Attendi..."

    <muovi il robot fino all' Aula2>

- Attendi che il reciever confermi l'avvenuta consegna(se timeout, torna ad Aula1 e segnala)
- Torna alla base



///////////////////////////////////
CLIENT 

> Effettua login (Nome Password Ruolo). Invia al SERVER
> Ricievi informazioni sulla coda dal server.

> Appena servito, segui le istruzioni fornite dal server


/////////////////////////////////////
IMPLEMENTAZIONE DEI TIMEOUT(ESEMPIO)

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

pthread_t tid;

// Your very slow function, it will finish running after 5 seconds, and print Exit message.
// But if we terminate the thread in 3 seconds, Exit message will not print.
void * veryslow(void *arg)
{
    fprintf(stdout, "Enter veryslow...\n");
    sleep(5);
    fprintf(stdout, "Exit veryslow...\n");

    return nullptr;
}

void alarm_handler(int a)
{
    fprintf(stdout, "Enter alarm_handler...\n");
    pthread_cancel(tid);    // terminate thread
}

int main()
{
    pthread_create(&tid, nullptr, veryslow, nullptr);

    signal(SIGALRM, alarm_handler);
    alarm(3);   // Run alarm_handler after 3 seconds, and terminate thread in it

    pthread_join(tid, nullptr); // Wait for thread finish

    return 0;
}


////////////////////////////////////
ROS

>Publisher:
    /move_base_simple/goal                  geometry_msgs/PoseStamped


>Subscriber:
    /odom                                   nav_msgs/Odometry
    /tf (listener)                          tf2_msgs/TFMessage
    /path_follower_status                   srrg2_navigation_2d_msgs/PathFollowerStatus
    /initial_pose (posa iniziale robot)     geometry_msgs/PoseWithCovarianceStamped


>Timer:
    Uno se ci metti troppo a mettere il pacco  
    Uno se ci metti troppo a riprenderlo
    (eventualmente uno se il robot si perde)






